#!/bin/sh /etc/rc.common

START=95
STOP=01
USE_PROCD=1

CONFIGURATION="AdGuardHome"
# 默认工作目录
DEFAULT_WORKDIR="/usr/bin/AdGuardHome"
# 默认配置文件路径
DEFAULT_CONFIGPATH="/etc/AdGuardHome.yaml"
# 默认二进制路径
DEFAULT_BINPATH="/usr/bin/AdGuardHome/AdGuardHome"

# 引入必要的库函数
. /lib/functions.sh

# 日志函数
log() {
	echo "[$(date '+%Y-%m-%d %H:%M:%S')] [AdGuardHome] $1" > /dev/console
	logger -t AdGuardHome "$1"
}

# 简单的 YAML 值读取/修改工具 (保留原有 awk 实现以兼容旧逻辑，但在 Phase 2 建议用 Lua 替代)
# 参数: yaml_key new_value file read_only
config_editor() {
	local key="$1"
	local val="$2"
	local file="$3"
	local ro="$4"

	[ ! -f "$file" ] && return 1

	# 如果是只读模式，直接尝试提取
	if [ "$ro" = "1" ]; then
		# 简单的 grep/sed 提取，比 awk 更快一点用于读取 (注意：仅适用于简单结构)
		# 为了兼容复杂层级，这里仍需保留一定的解析能力，暂时复用原有的 awk 逻辑核心精简版
		awk -v k="$key" -F: '
			BEGIN { split(k, parts, "."); depth=1; found=0 }
			{
				# 简单层级匹配逻辑
				if ($1 ~ parts[depth]) {
					if (depth == length(parts)) {
						val=$2; gsub(/^ +/, "", val); print val; exit 0
					}
					depth++
				}
			}
		' "$file"
		return $?
	fi

	# 写入模式：为了安全，建议 Phase 2 使用 lua 脚本处理。
	# 暂时保留原逻辑的调用方式，但将其作为外部命令调用的占位符，
	# 实际运行中，如果只是修改端口，可以依赖 AGH 自身的参数或 sed
	# 这里为了稳定性，暂时不执行复杂的 awk 写入，而是依靠启动参数覆盖端口，
	# 或者如果必须修改文件，使用 sed (仅限 port/address 等简单项)
	
	if [ "$key" = "dns.port" ]; then
		sed -i "s/^\s*port:\s*[0-9]\+/  port: $val/" "$file"
	elif [ "$key" = "users.0.password" ]; then
		# 这是一个复杂的替换，暂时跳过或保留原 awk 逻辑（如果非常必要）
		# 考虑到 Phase 1 主要优化系统层，这里不做激进改动，仅做兼容
		:
	fi
}

# 处理 dnsmasq 上游设置 (保留 UCI 操作，这是最稳妥的方法)
set_dnsmasq_upstream() {
	local port="$1"
	local server="127.0.0.1#${port}"
	
	# 检查是否已经是该配置
	local current_servers=$(uci -q get dhcp.@dnsmasq[0].server)
	if echo "$current_servers" | grep -q "$server"; then
		return
	fi

	# 清理旧的包含 127.0.0.1 的配置，防止堆积
	# 注意：这可能会误删用户自己配置的其他本地转发，需谨慎
	# 这里采用保守策略：只添加，清理逻辑在 disable 时执行
	uci add_list dhcp.@dnsmasq[0].server="$server"
	uci set dhcp.@dnsmasq[0].noresolv='1'
	uci delete dhcp.@dnsmasq[0].resolvfile 2>/dev/null
	uci commit dhcp
	/etc/init.d/dnsmasq reload
}

unset_dnsmasq_upstream() {
	local port="$1"
	local server="127.0.0.1#${port}"
	
	uci del_list dhcp.@dnsmasq[0].server="$server" 2>/dev/null
	
	# 如果删除了所有 server，可能需要恢复默认解析行为
	local remaining=$(uci -q get dhcp.@dnsmasq[0].server)
	if [ -z "$remaining" ]; then
		uci delete dhcp.@dnsmasq[0].noresolv 2>/dev/null
		# 尝试恢复 resolvfile，这通常是 /tmp/resolv.conf.auto
		uci set dhcp.@dnsmasq[0].resolvfile="/tmp/resolv.conf.auto"
	fi
	uci commit dhcp
	/etc/init.d/dnsmasq reload
}

start_service() {
	config_load "$CONFIGURATION"
	
	local enabled
	config_get_bool enabled "AdGuardHome" enabled 0
	[ "$enabled" -eq 1 ] || return 0

	local binpath configpath workdir logfile httpport verbose redirect upxflag
	config_get binpath "AdGuardHome" binpath "$DEFAULT_BINPATH"
	config_get configpath "AdGuardHome" configpath "$DEFAULT_CONFIGPATH"
	config_get workdir "AdGuardHome" workdir "$DEFAULT_WORKDIR"
	config_get logfile "AdGuardHome" logfile ""
	config_get httpport "AdGuardHome" httpport "3000"
	config_get redirect "AdGuardHome" redirect "none"
	config_get_bool verbose "AdGuardHome" verbose 0

	# 检查二进制文件
	if [ ! -x "$binpath" ]; then
		log "Error: Binary not found or not executable at $binpath"
		return 1
	fi

	# 准备工作目录
	mkdir -p "$workdir/data"
	
	# JFFS2 特殊处理 (防止频繁读写磨损 Flash)
	local fs_type=$(df -T "$workdir" | awk 'NR==2 {print $2}')
	if [ "$fs_type" = "jffs2" ] || [ "$fs_type" = "overlayfs" ]; then
		# 仅链接高频读写的数据库文件
		for db in stats.db sessions.db querylog.json; do
			if [ ! -L "$workdir/data/$db" ]; then
				[ -f "$workdir/data/$db" ] && mv "$workdir/data/$db" "/tmp/$db"
				ln -sf "/tmp/$db" "$workdir/data/$db"
			fi
		done
	fi

	# 获取实际运行的 DNS 端口 (用于防火墙/dnsmasq设置)
	# 优先从 YAML 读取，如果失败则假定默认或不处理
	local dns_port=$(grep -m 1 "^  port:" "$configpath" | awk '{print $2}')
	[ -z "$dns_port" ] && dns_port=53

	# 处理重定向逻辑
	case "$redirect" in
		dnsmasq-upstream)
			set_dnsmasq_upstream "$dns_port"
			;;
		exchange)
			# 交换端口逻辑较复杂，建议在 Phase 2 移至 Lua 处理
			# 这里为了保持服务启动，暂时假设用户已配置好端口
			# 仅做日志提示
			log "Mode 'exchange': ensuring dnsmasq is not on port 53"
			# 简单检查：如果 dnsmasq 还在 53，尝试移走 (这是一个有风险的操作，但在 init 中只能这样)
			local masq_port=$(uci -q get dhcp.@dnsmasq[0].port || echo 53)
			if [ "$masq_port" = "53" ]; then
				uci set dhcp.@dnsmasq[0].port="5353"
				uci commit dhcp
				/etc/init.d/dnsmasq reload
			fi
			;;
		redirect)
			# 纯防火墙重定向模式，不再此处操作 UCI firewall
			# 而是依赖 firewall.include 脚本
			# 可以在此处触发一次防火墙重载以确保规则生效
			/etc/init.d/firewall reload
			;;
	esac

	# 启动进程
	procd_open_instance
	procd_set_param command "$binpath"
	procd_append_param command -c "$configpath"
	procd_append_param command -w "$workdir"
	procd_append_param command -p "$httpport"
	[ -n "$logfile" ] && [ "$logfile" != "syslog" ] && procd_append_param command -l "$logfile"
	[ "$verbose" -eq 1 ] && procd_append_param command -v

	# 资源限制
	procd_set_param limits core="unlimited" nofile="65535 65535"
	
	# 服务配置
	procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-5}
	procd_set_param stderr 1
	procd_set_param stdout 1
	
	# 核心优化：利用 Procd 监控配置文件，变化时自动重载
	procd_set_param file "$configpath"
	
	procd_close_instance
}

stop_service() {
	# 恢复 dnsmasq 配置
	# 注意：无法精确知道之前设置了哪个端口，只能尝试恢复标准状态
	# 或者读取当前运行配置
	# 这里简化处理：如果是 dnsmasq-upstream 模式，移除列表
	
	config_load "$CONFIGURATION"
	local redirect
	config_get redirect "AdGuardHome" redirect "none"
	
	if [ "$redirect" = "dnsmasq-upstream" ]; then
		# 尝试移除所有指向本地非53端口的配置? 
		# 更安全的是只移除我们可能添加的。
		# 由于缺少状态存储，这里可能需要依赖 config_editor 读取 yaml 端口
		local configpath
		config_get configpath "AdGuardHome" configpath "$DEFAULT_CONFIGPATH"
		local dns_port=$(grep -m 1 "^  port:" "$configpath" | awk '{print $2}')
		[ -n "$dns_port" ] && unset_dnsmasq_upstream "$dns_port"
	fi
	
	# 移除重定向标记文件 (如果存在)
	rm -f /var/run/AdGredir
}

service_triggers() {
	procd_add_reload_trigger "AdGuardHome"
	# 当网络接口发生变化（如重新拨号、IP变更）时，重载服务以确保绑定正确
	procd_add_reload_interface_trigger "lan"
	procd_add_reload_interface_trigger "wan"
}

# 兼容旧指令，避免报错
do_redirect() { :; }
testbackup() { :; }
force_reload() { /etc/init.d/AdGuardHome reload; }