#!/bin/sh /etc/rc.common
# Copyright (C) 2018-2024 Lienol <https://github.com/Lienol>
# Copyright (C) 2024 rufengsuixing <https://github.com/rufengsuixing>

# 启用错误退出
set -e

USE_PROCD=1
START=95
STOP=01

CONFIGURATION="AdGuardHome"
CRON_FILE="/etc/crontabs/root"
GFWSET="gfwlist"
EXTRA_COMMANDS="do_redirect testbackup test_crontab force_reload isrunning"
EXTRA_HELP="        do_redirect 0 or 1
        testbackup backup or restore
        test_crontab
        force_reload
        isrunning"

# 日志函数
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - AdGuardHome Init: $1" >> /tmp/AdGuardHome_init.log # 简单的日志记录，可以替换为 logger
}

# 检查命令是否存在
check_command() {
    command -v "$1" >/dev/null 2>&1 || { log "Error: command '$1' not found."; exit 1; }
}

set_forward_dnsmasq() {
    local PORT="$1"
    local addr="127.0.0.1#${PORT}"
    local OLD_SERVER
    OLD_SERVER=$(uci -q get dhcp.@dnsmasq[0].server)
    # 使用 grep -q 优化检查
    if echo "$OLD_SERVER" | grep -q "^${addr}"; then
        return
    fi
    uci delete dhcp.@dnsmasq[0].server 2>/dev/null || true
    uci add_list dhcp.@dnsmasq[0].server="$addr"
    for server in $OLD_SERVER; do
        if [ "$server" = "$addr" ]; then
            continue
        fi
        uci add_list dhcp.@dnsmasq[0].server="$server"
    done
    uci delete dhcp.@dnsmasq[0].resolvfile 2>/dev/null || true
    uci set dhcp.@dnsmasq[0].noresolv=1
    uci commit dhcp
    log "Setting dnsmasq upstream to $addr"
    /etc/init.d/dnsmasq restart || log "Error restarting dnsmasq"
}

stop_forward_dnsmasq() {
    local OLD_PORT="$1"
    local addr="127.0.0.1#${OLD_PORT}"
    local OLD_SERVER
    OLD_SERVER=$(uci -q get dhcp.@dnsmasq[0].server)
    # 使用 grep -q 优化检查
    if ! echo "$OLD_SERVER" | grep -q "^${addr}"; then
        return
    fi

    uci del_list dhcp.@dnsmasq[0].server="$addr" 2>/dev/null || true
    local rcauto="/tmp/resolv.conf.auto"
    [ -e "/tmp/resolv.conf.d/resolv.conf.auto" ] && rcauto="/tmp/resolv.conf.d/resolv.conf.auto"

    local addrlist
    addrlist=$(uci -q get dhcp.@dnsmasq[0].server)
    if [ -z "$addrlist" ]; then
        uci set dhcp.@dnsmasq[0].resolvfile="$rcauto"
        uci delete dhcp.@dnsmasq[0].noresolv 2>/dev/null || true
    fi
    uci commit dhcp
    log "Removing dnsmasq upstream $addr"
    /etc/init.d/dnsmasq restart || log "Error restarting dnsmasq"
}

set_iptable() {
    local port="$1" # AdGuardHome 端口
    # 检查必要的命令
    check_command uci
    check_command iptables

    local section
    section=$(uci add firewall redirect)
    if [ -z "$section" ]; then
        log "Error: failed to add firewall redirect rule."
        return 1
    fi
    uci batch <<EOF
set firewall.$section.target="DNAT"
set firewall.$section.name="AdGuard Home DNS" # 名字更明确
set firewall.$section.src="lan"
set firewall.$section.proto="tcp udp" # 同时重定向 TCP 和 UDP
set firewall.$section.src_dport="53"
set firewall.$section.dest_port="${port}"
EOF
    uci commit firewall
    /etc/init.d/firewall reload || log "Error reloading firewall"
    log "Firewall redirect rule added for port ${port}."
}

clear_iptable() {
    # 检查必要的命令
    check_command uci
    check_command iptables

    local redirects
    # 使用更精确的 grep 匹配 name 选项
    redirects=$(uci show firewall | grep '=redirect' | grep ".name='AdGuard Home DNS'" | awk -F '.' '{print $2}')
    if [ -z "$redirects" ]; then
        log "No AdGuard Home DNS redirect rules found."
    else
        local changed=0
        for section in $redirects; do
            uci delete firewall."$section"
            log "Deleted redirect rule: firewall.$section"
            changed=1
        done
        if [ "$changed" -eq 1 ]; then
            uci commit firewall
            /etc/init.d/firewall reload || log "Error reloading firewall"
            log "Firewall rules updated."
        fi
    fi
}

service_triggers() {
    procd_add_reload_trigger "$CONFIGURATION"
    [ "$(uci -q get AdGuardHome.AdGuardHome.redirect)" = "redirect" ] && procd_add_reload_trigger firewall
}

isrunning() {
    config_load "${CONFIGURATION}"
    _isrunning
    local r=$?
    case $r in
        0) echo "running" ;;
        1) echo "not run" ;;
        2) echo "no bin" ;;
    esac
    return $r
}

_isrunning() {
    local binpath
    config_get binpath "$CONFIGURATION" binpath "/usr/bin/AdGuardHome" # 默认路径修正
    [ ! -f "$binpath" ] && return 2
    # 使用 pgrep 检查进程
    pgrep -f "^${binpath}" >/dev/null 2>&1 && return 0
    return 1
}

force_reload() {
    config_load "${CONFIGURATION}"
    if _isrunning; then
        log "Force reloading AdGuardHome service..."
        procd_send_signal "$CONFIGURATION"
    else
        log "AdGuardHome not running, starting..."
        start
    fi
}

get_tz() {
    SET_TZ=""
    # OpenWrt/ImmortalWrt 通常通过 /etc/config/system 获取时区
    local tz_config
    tz_config=$(uci -q get system.@system[0].timezone)
    if [ -n "$tz_config" ]; then
        SET_TZ="$tz_config"
        return
    fi

    # 备用方案：检查 /etc/TZ 或 /var/etc/TZ
    local tzfile tz
    for tzfile in /etc/TZ /var/etc/TZ; do
        if [ -e "$tzfile" ]; then
            tz=$(cat "$tzfile" 2>/dev/null)
            if [ -n "$tz" ]; then
                SET_TZ="$tz"
                return
            fi
        fi
    done
    log "Timezone not found."
}

# 优化 config_editor 函数
config_editor() {
    local yaml_path="$1" # YAML 键路径，例如 dns.port
    local value="$2"     # 新的值，如果为空字符串，则表示读取
    local file="$3"      # 配置文件路径
    local readonly="$4"  # 只读标记，1 表示只读

    [ -z "$file" ] || [ ! -f "$file" ] && { log "Error: Config file '$file' not found or not specified."; return 1; }

    # 使用 awk 处理 YAML 文件
    awk -v yaml="$yaml_path" -v value="$value" -v file="$file" -v ro="$readonly" '
    BEGIN {
        split(yaml, parts, ".");
        current_indent = "";
        found = 0;
        target_depth = length(parts);
        current_depth = 1;
        in_correct_section = 1; # 标记是否在正确的父级下
        indent_levels[0] = -1; # 存储每一层的缩进
    }
    {
        # 计算当前行的缩进
        match($0, /^(\s*)/);
        indent = length(RLENGTH);
        key = "";
        current_val = "";
        line_content = substr($0, indent + 1);

        # 跳过空行和注释
        if (line_content == "" || substr(line_content, 1, 1) == "#") {
            print; # 保留原样
            next;
        }

        # 更新当前深度
        while (indent <= indent_levels[current_depth - 1] && current_depth > 1) {
            current_depth--;
            in_correct_section = (current_depth <= target_depth && parts[current_depth] == current_key[current_depth]);
        }
        indent_levels[current_depth] = indent;

        # 解析 key: value
        if (match(line_content, /^([^:]+):\s*(.*)/, arr)) {
            key = arr[1];
            current_val = arr[2];
            sub(/^\s+|\s+$/, "", key); # 去除 key 的前后空格
        } else {
            # 处理非 key: value 的行（例如列表项）
            print;
            next;
        }

        # 记录当前层的 key
        current_key[current_depth] = key;

        # 检查是否在目标路径上
        is_target_path = 1;
        for (i = 1; i <= current_depth; i++) {
            if (parts[i] != current_key[i]) {
                is_target_path = 0;
                break;
            }
        }
        # 如果当前路径匹配，且父路径也匹配
        if (is_target_path && in_correct_section) {
            if (current_depth == target_depth) {
                # 找到目标键
                found = 1;
                if (ro == "1") {
                    # 只读模式，输出值
                    print current_val;
                    exit; # 找到即退出
                } else {
                    # 写模式，打印修改后的行
                    print current_indent key ": " value;
                }
            } else {
                # 进入下一层级
                current_indent = sprintf("%*s", indent + 2, ""); # 假设缩进为2空格
                current_depth++;
                in_correct_section = 1; # 进入了正确的子层
            }
        } else {
             # 不在目标路径上，或父路径不匹配，重置 in_correct_section 标记
             in_correct_section = 0;
             print; # 打印原始行
        }

    }
    END {
        if (found == 0 && ro != "1") {
             # 如果写模式下未找到键，可以在此处理添加新键的逻辑（较复杂，暂不实现）
             # 这里简单地不修改文件
             # print "Key not found for writing: " yaml > "/dev/stderr"; # 输出错误到 stderr
             exit 1; # 表示未成功修改
        }
         if (found == 0 && ro == "1") {
              # print "Key not found for reading: " yaml > "/dev/stderr";
              exit 1; # 表示未找到
         }
    }' "$file" > "${file}.tmp" # 将结果输出到临时文件

    local awk_exit_code=$?
    if [ "$readonly" != "1" ]; then
        if [ $awk_exit_code -eq 0 ]; then
            # 如果 awk 成功执行（找到了键并修改），则替换原文件
            mv "${file}.tmp" "$file"
            log "Updated key '$yaml_path' in '$file'"
            return 0
        else
            # 如果 awk 执行失败（未找到键），删除临时文件
            rm -f "${file}.tmp"
            log "Key '$yaml_path' not found in '$file' for writing."
            return 1
        fi
    else
        # 只读模式，如果 awk 成功（找到了并打印了值），则返回 0，否则返回 1
        rm -f "${file}.tmp" # 删除临时文件
        if [ $awk_exit_code -eq 0 ]; then
             return 0
        else
             log "Key '$yaml_path' not found in '$file' for reading."
             return 1
        fi
    fi
}


# 修改 get_filesystem 为更健壮的版本
get_filesystem() {
    local target_path="$1"
    local best_match_mount=""
    local best_match_length=0
    local fs_type=""
    local mount_dev=""

    # 读取 mount 信息
    while IFS= read -r line; do
        # 解析 mount 行: device on /path type ...
        local device path type options
        device=$(echo "$line" | awk '{print $1}')
        path=$(echo "$line" | awk '{print $3}')
        type=$(echo "$line" | awk '{print $5}')
        # shellcheck disable=SC2034 # options is currently unused but might be useful later
        options=$(echo "$line" | awk '{print $6}') # Example: (rw,relatime)

        # 检查路径是否是目标路径的前缀
        if [ "${target_path#$path}" != "$target_path" ]; then
            # 检查是否是最长匹配
            local current_length=${#path}
            if [ "$current_length" -gt "$best_match_length" ]; then
                best_match_length="$current_length"
                best_match_mount="$path"
                fs_type="$type"
                # shellcheck disable=SC2034 # mount_dev currently unused
                mount_dev="$device"
            fi
        fi
    done < <(mount) # 使用进程替换读取 mount 输出

    if [ -z "$fs_type" ]; then
        log "Warning: Could not determine filesystem type for path '$target_path'" >&2
        # Fallback? Maybe return default or try df? 'df' might not be available.
        # Let's try df as a fallback if available
        if command -v df >/dev/null 2>&1; then
           fs_type=$(df -P "$target_path" | awk 'NR==2 {print $1}') # Get device and maybe infer type later if needed
           log "Fallback using df: device $fs_type" >&2
           # Attempting to get fstype from device using mount again (might be redundant)
           if [ -n "$fs_type" ]; then
               local fallback_type=$(mount | grep "^$fs_type " | awk '{print $5}')
                if [ -n "$fallback_type" ]; then
                    fs_type="$fallback_type"
                else
                    fs_type="unknown_via_df" # Indicate fallback method
                fi
           fi
        else
            fs_type="unknown"
        fi
    fi
    echo "$fs_type"
}

rm_port53() {
    local configpath
    config_get configpath "$CONFIGURATION" configpath "/etc/AdGuardHome.yaml"
    local AdGuardHome_PORT
    # shellcheck disable=SC2034 # Readonly variable, store output directly
    AdGuardHome_PORT=$(config_editor "dns.port" "" "$configpath" "1")
    if [ $? -ne 0 ] || [ -z "$AdGuardHome_PORT" ]; then
       log "Error reading AdGuardHome DNS port."
       return 1
    fi

    local dnsmasq_port
    dnsmasq_port=$(uci -q get dhcp.@dnsmasq[0].port) || dnsmasq_port="53" # Default to 53 if not set

    if [ "$dnsmasq_port" = "$AdGuardHome_PORT" ]; then
        # Ports clash, need to move dnsmasq back to 53
        log "Ports clashed ($dnsmasq_port), moving dnsmasq back to 53."
    elif [ "$dnsmasq_port" = "53" ]; then
        # Dnsmasq is already on 53, AdGuardHome was likely using another port. No change needed for dnsmasq.
        log "Dnsmasq already on port 53. No change needed."
        return 0
    else
        # Dnsmasq is on a non-53 port, AdGuardHome likely on 53. Move dnsmasq back to 53.
        log "Dnsmasq on port $dnsmasq_port, moving back to 53."
    fi

    uci set dhcp.@dnsmasq[0].port="53"
    uci commit dhcp
    /etc/init.d/dnsmasq restart || log "Error restarting dnsmasq"
}

use_port53() {
    local configpath
    config_get configpath "$CONFIGURATION" configpath "/etc/AdGuardHome.yaml"
    local AdGuardHome_PORT
    # shellcheck disable=SC2034 # Readonly variable, store output directly
    AdGuardHome_PORT=$(config_editor "dns.port" "" "$configpath" "1")
     if [ $? -ne 0 ] || [ -z "$AdGuardHome_PORT" ]; then
       log "Error reading AdGuardHome DNS port."
       return 1
    fi

    local dnsmasq_port
    dnsmasq_port=$(uci -q get dhcp.@dnsmasq[0].port) || dnsmasq_port="53" # Default to 53 if not set

    if [ "$AdGuardHome_PORT" = "53" ]; then
        # AdGuardHome is already on 53. Ensure dnsmasq is not.
        if [ "$dnsmasq_port" = "53" ]; then
             local new_dnsmasq_port="5353" # Choose a different port for dnsmasq
             log "AdGuardHome already on 53, moving dnsmasq to $new_dnsmasq_port."
             uci set dhcp.@dnsmasq[0].port="$new_dnsmasq_port"
             uci commit dhcp
             /etc/init.d/dnsmasq restart || log "Error restarting dnsmasq"
        else
            log "AdGuardHome already on port 53, dnsmasq on $dnsmasq_port. No change needed."
            return 0
        fi
    else
        # AdGuardHome is not on 53. Move it to 53 and move dnsmasq away if needed.
        local new_dnsmasq_port="$AdGuardHome_PORT" # Use AGH's current port for dnsmasq
        if [ "$dnsmasq_port" = "53" ]; then
            log "Moving AdGuardHome to 53 and dnsmasq to $new_dnsmasq_port."
            if config_editor "dns.port" "53" "$configpath"; then
                 uci set dhcp.@dnsmasq[0].port="$new_dnsmasq_port"
                 uci commit dhcp
                 /etc/init.d/dnsmasq restart || log "Error restarting dnsmasq"
            else
                 log "Error setting AdGuardHome port to 53."
                 return 1
            fi
        else
            # Dnsmasq already not on 53, just move AGH to 53
            log "Moving AdGuardHome to 53. Dnsmasq remains on $dnsmasq_port."
             if ! config_editor "dns.port" "53" "$configpath"; then
                  log "Error setting AdGuardHome port to 53."
                  return 1
             fi
             # No need to restart dnsmasq if its port didn't change
        fi
    fi
}

do_redirect() {
    config_load "${CONFIGURATION}"
    _do_redirect "$1"
}

_do_redirect() {
    local enabled="$1"
    local section="$CONFIGURATION"
    local configpath old_redirect redirect old_port AdGuardHome_PORT old_enabled

    if [ "$enabled" = "1" ]; then
        echo -n "1" > /var/run/AdGredir
    else
        echo -n "0" > /var/run/AdGredir
    fi

    config_get configpath "$section" configpath "/etc/AdGuardHome.yaml"
    if [ ! -f "$configpath" ] && [ "$enabled" = "1" ]; then
        log "Warning: config file '$configpath' not found. Cannot determine AdGuardHome port. Redirect disabled."
        enabled=0 # Disable redirect if config is missing
        echo -n "0" > /var/run/AdGredir
    fi

    if [ "$enabled" = "1" ]; then
      # shellcheck disable=SC2034 # Readonly variable, store output directly
      AdGuardHome_PORT=$(config_editor "dns.port" "" "$configpath" "1")
      if [ $? -ne 0 ] || [ -z "$AdGuardHome_PORT" ]; then
           log "Error reading AdGuardHome DNS port from '$configpath'. Redirect disabled."
           enabled=0 # Disable redirect if port cannot be read
           echo -n "0" > /var/run/AdGredir
      fi
    else
       AdGuardHome_PORT="0" # Set to 0 if disabled
    fi


    config_get redirect "$section" redirect "none"
    config_get old_redirect "$section" old_redirect "none"
    config_get old_port "$section" old_port "0"
    config_get old_enabled "$section" old_enabled "0"

    # Ensure dnsmasq port is defined in UCI for comparison/modification later
    uci -q get dhcp.@dnsmasq[0].port || uci set dhcp.@dnsmasq[0].port="53"

    # Determine the actual AGH port used in the *previous* state if mode was 'exchange'
    local effective_old_agh_port="$old_port"
    if [ "$old_enabled" = "1" ] && [ "$old_redirect" = "exchange" ]; then
         # In the previous state, dnsmasq held AGH's original port.
         effective_old_agh_port=$(uci -q get dhcp.@dnsmasq[0].port) || effective_old_agh_port="$old_port" # Fallback
    fi


    # Clean up old rules if state changed or service disabled
    if [ "$old_redirect" != "$redirect" ] || [ "$effective_old_agh_port" != "$AdGuardHome_PORT" ] || [ "$old_enabled" = "1" -a "$enabled" = "0" ]; then
        log "State change detected (old: $old_redirect/$effective_old_agh_port/$old_enabled, new: $redirect/$AdGuardHome_PORT/$enabled). Cleaning up old rules..."
        case "$old_redirect" in
            redirect)
                [ "$effective_old_agh_port" != "0" ] && clear_iptable
                ;;
            dnsmasq-upstream)
                [ "$effective_old_agh_port" != "0" ] && stop_forward_dnsmasq "$effective_old_agh_port"
                ;;
            exchange)
                # Ensure dnsmasq is back on 53 if AGH was using it
                rm_port53
                ;;
        esac
    elif [ "$old_enabled" = "1" ] && [ "$enabled" = "1" ] && [ "$old_redirect" = "redirect" ] && [ "$effective_old_agh_port" != "0" ] && [ "$effective_old_agh_port" != "$AdGuardHome_PORT" ]; then
         # Special case: still redirect mode, still enabled, but port changed
         log "Redirect port changed from $effective_old_agh_port to $AdGuardHome_PORT. Updating firewall rule..."
         clear_iptable # Clear old rule first
         # The new rule will be set below if enabled=1
    fi


    # Update stored state
    uci delete "${CONFIGURATION}.${section}.old_redirect" 2>/dev/null || true
    uci delete "${CONFIGURATION}.${section}.old_port" 2>/dev/null || true
    uci delete "${CONFIGURATION}.${section}.old_enabled" 2>/dev/null || true
    # Use single set instead of add_list for single values
    uci set "${CONFIGURATION}.${section}.old_redirect=$redirect"
    uci set "${CONFIGURATION}.${section}.old_port=$AdGuardHome_PORT"
    uci set "${CONFIGURATION}.${section}.old_enabled=$enabled"
    uci commit "$CONFIGURATION"

    [ "$enabled" = "0" ] && { log "Redirect disabled."; return 1; }
    [ "$AdGuardHome_PORT" = "0" ] && { log "AdGuardHome port is 0, cannot enable redirect."; return 1; }

    # Apply new rules
    log "Applying redirect mode: $redirect for port $AdGuardHome_PORT"
    case "$redirect" in
        redirect)
            set_iptable "$AdGuardHome_PORT"
            ;;
        dnsmasq-upstream)
            set_forward_dnsmasq "$AdGuardHome_PORT"
            ;;
        exchange)
             # Move AGH to 53, dnsmasq away from 53
             use_port53
            ;;
        *)
            log "Redirect mode 'none' or unknown: '$redirect'."
            ;;
    esac
}


boot_service() {
    rm /var/run/AdGserverdis >/dev/null 2>&1 || true # Ignore error if file doesn't exist
    config_load "${CONFIGURATION}"
    local waitonboot enabled binpath
    config_get waitonboot "$CONFIGURATION" waitonboot "0"
    config_get_bool enabled "$CONFIGURATION" enabled 0
    config_get binpath "$CONFIGURATION" binpath "/usr/bin/AdGuardHome" # Correct default path

    if [ ! -f "$binpath" ]; then
        log "AdGuardHome binary not found at '$binpath'. Cannot start service."
        # Optionally trigger download here if needed at boot
        return 1
    fi

    # Start the main service using procd
    start_service

    # Start waitnet.sh if enabled and configured
    if [ "$enabled" = "1" ] && [ "$waitonboot" = "1" ]; then
        log "Starting waitnet script..."
        procd_open_instance "waitnet"
        procd_set_param command "/usr/share/AdGuardHome/waitnet.sh"
        # Consider adding respawn parameters if needed
        procd_close_instance
        log "waitnet script started in background."
    fi
}

testbackup() {
    config_load "${CONFIGURATION}"
    case "$1" in
        backup)
            log "Manual backup triggered."
            backup
            ;;
        restore)
            log "Manual restore triggered."
            restore
            ;;
        *)
            echo "Usage: $0 testbackup [backup|restore]" >&2
            return 1
            ;;
    esac
}

restore() {
    local workdir backupwdpath
    config_get workdir "$CONFIGURATION" workdir "/usr/bin/AdGuardHome"
    config_get backupwdpath "$CONFIGURATION" backupwdpath "/usr/bin/AdGuardHome"

    if [ ! -d "$backupwdpath/data" ]; then
        log "Backup directory '$backupwdpath/data' not found. Nothing to restore."
        return 1
    fi
     if [ ! -d "$workdir" ]; then
        log "Work directory '$workdir' does not exist. Creating."
        mkdir -p "$workdir" || { log "Error creating workdir '$workdir'"; return 1; }
    fi
    log "Restoring data from '$backupwdpath/data' to '$workdir/data'..."
    # -u: update only if source is newer or destination doesn't exist
    # -r: recursive
    # -f: force overwrite without prompt (use with caution, maybe add check first?)
    # -p: preserve permissions, ownership, timestamps
    cp -u -r -p -f "$backupwdpath/data" "$workdir" && log "Restore completed." || log "Error during restore."
}

backup() {
    local backupwdpath workdir backupfile cpret one
    config_get backupwdpath "$CONFIGURATION" backupwdpath "/usr/bin/AdGuardHome"
    config_get workdir "$CONFIGURATION" workdir "/usr/bin/AdGuardHome"
    config_get backupfile "$CONFIGURATION" backupfile ""

    if [ -z "$backupfile" ]; then
        log "No files configured for backup."
        return 0
    fi

    mkdir -p "$backupwdpath/data" || { log "Error creating backup directory '$backupwdpath/data'"; return 1; }
    log "Starting backup to '$backupwdpath/data'..."

    for one in $backupfile; do
        local source_path="$workdir/data/$one"
        local dest_path="$backupwdpath/data" # Backup directly into backup/data

        if [ ! -e "$source_path" ]; then
             log "Warning: Source file/directory '$source_path' does not exist. Skipping."
             continue
        fi

        log "Backing up '$one'..."
        while : ; do
            # Use -a (archive mode: -rlptgoD) for better preservation, -u for update
            # Redirect stderr to stdout to capture errors
             cpret=$(cp -a -u -f "$source_path" "$dest_path" 2>&1)
             local cp_exit_code=$?
             echo "$cpret" # Log cp output

             if [ $cp_exit_code -ne 0 ]; then
                if echo "$cpret" | grep -q "no space left on device"; then
                    log "Disk full during backup of '$one'. Attempting to delete querylog..."
                    if del_querylog; then # del_querylog should return 0 on success
                        log "Querylog deleted. Retrying backup of '$one'..."
                        continue # Retry cp
                    else
                         log "Failed to delete querylog or querylog empty. Trying to delete filters backup..."
                         rm -f -r "$backupwdpath/data/filters" 2>/dev/null || true # Attempt to remove filters backup
                         # Optionally remove filters from workdir too? Be careful.
                         # rm -f -r "$workdir/data/filters" 2>/dev/null || true
                         log "Attempting to retry backup of '$one' after deleting filters..."
                         continue # Retry cp one last time
                    fi
                    log "Backup failed for '$one' due to insufficient space even after cleanup attempts."
                else
                    log "Error during backup of '$one': $cpret"
                fi
             fi
            break # Exit loop if cp succeeded or failed for reasons other than space
        done
    done
    log "Backup process finished."
}

start_service() {
    rm /var/run/AdGserverdis >/dev/null 2>&1 || true
    config_load "${CONFIGURATION}"

    local enabled hashpass configpath workdir backupfile cwdfs binpath httpport logfile verbose redirect upprotect
    local ADDITIONAL_ARGS=""
    local ipst=0

    # Get config values
    config_get_bool enabled "$CONFIGURATION" enabled 0
    config_get hashpass "$CONFIGURATION" hashpass ""
    config_get configpath "$CONFIGURATION" configpath "/etc/AdGuardHome.yaml"
    config_get workdir "$CONFIGURATION" workdir "/usr/bin/AdGuardHome"
    config_get binpath "$CONFIGURATION" binpath "/usr/bin/AdGuardHome"
    config_get httpport "$CONFIGURATION" httpport 3000
    config_get logfile "$CONFIGURATION" logfile ""
    config_get_bool verbose "$CONFIGURATION" verbose 0
    config_get redirect "$CONFIGURATION" redirect "none"
    config_get upprotect "$CONFIGURATION" upprotect ""
    config_get backupfile "$CONFIGURATION" backupfile ""

    # Update crontab based on current settings
    do_crontab

    if [ "$enabled" = "0" ]; then
        log "Service disabled in config."
        _do_redirect 0
        return 1
    fi

    # Check if binary exists, if not, try to update/download
    if [ ! -f "$binpath" ]; then
        log "AdGuardHome binary not found at '$binpath'. Attempting to download..."
        _do_redirect 0 # Ensure redirect is off
        # Run update in background and log output
        /usr/share/AdGuardHome/update_core.sh > /tmp/AdGuardHome_update.log 2>&1 &
        # Exit start_service, update script will handle starting if successful
        return 1 # Indicate service did not start now
    fi

    # Update password hash if set in UCI
    if [ -n "$hashpass" ]; then
        log "Updating password hash in '$configpath'..."
        if config_editor "users.0.password" "$hashpass" "$configpath"; then # Assuming first user
            uci set "${CONFIGURATION}.${CONFIGURATION}.hashpass="
            uci commit "$CONFIGURATION"
            log "Password hash updated."
        else
            log "Error updating password hash in '$configpath'."
            # Decide if this is a fatal error? Maybe just log and continue.
        fi
    fi


    # Prepare work directory and handle restore if needed
    mkdir -p "$workdir/data" || { log "Error creating workdir/data '$workdir/data'"; return 1; }
    if [ -n "$backupfile" ] && [ ! -d "$workdir/data" ] && [ -z "$(ls -A "$workdir/data")" ]; then # Restore only if workdir/data is empty
         log "Workdir data is empty, attempting restore..."
         restore
    fi

    # Check filesystem and handle jffs2 workaround
    cwdfs=$(get_filesystem "$workdir")
    log "Workdir filesystem is '$cwdfs'."
    if [ "$cwdfs" = "jffs2" ]; then
        log "jffs2 filesystem detected for workdir. Applying symlink workaround for databases..."
        logger "AdGuardHome" "Warning: workdir on jffs2, redirecting databases to /tmp. Data will be lost on reboot."
        for db_file in stats.db sessions.db querylog.json; do # Add other potential db files if needed
            local db_path="$workdir/data/$db_file"
            local tmp_path="/tmp/$db_file"
            if [ -e "$db_path" ] && [ ! -L "$db_path" ]; then
                log "Moving '$db_file' to /tmp and creating symlink."
                # Move existing file only if it's not already a symlink
                mv -f "$db_path" "$tmp_path" 2>/dev/null || true # Ignore error if move fails (e.g., source doesn't exist)
                ln -s "$tmp_path" "$db_path" 2>/dev/null || true # Ignore error if link exists
            elif [ ! -e "$db_path" ]; then
                 # If file doesn't exist, create symlink pointing to /tmp
                 log "Creating symlink for '$db_file' pointing to /tmp."
                 ln -s "$tmp_path" "$db_path" 2>/dev/null || true
            fi
        done
    fi

    # Check ipset requirement (More robust check)
    if [ -f "$configpath" ] && grep -qE '^\s*ipset:\s*\[.+\]' "$configpath"; then
         ipst=1
         log "ipset configuration detected in '$configpath'."
         check_command ipset # Check if ipset command exists
         # Ensure the set exists
         ipset list "$GFWSET" >/dev/null 2>&1 || {
            log "Creating ipset '$GFWSET'..."
            ipset create "$GFWSET" hash:ip || log "Error creating ipset '$GFWSET'. Ignoring." # Log error but continue
         }
    fi


    # Build command arguments
    ADDITIONAL_ARGS="$ADDITIONAL_ARGS -c \"$configpath\"" # Quote paths
    ADDITIONAL_ARGS="$ADDITIONAL_ARGS -w \"$workdir\""
    ADDITIONAL_ARGS="$ADDITIONAL_ARGS -p \"$httpport\""
    [ -n "$logfile" ] && ADDITIONAL_ARGS="$ADDITIONAL_ARGS -l \"$logfile\""
    [ "$verbose" -eq 1 ] && ADDITIONAL_ARGS="$ADDITIONAL_ARGS -v"

    # Setup /lib/upgrade/keep.d for sysupgrade persistence
    # Use eval carefully, ensure paths are safe
    # Consider alternative: loop and echo each path separately
    local keep_file="/lib/upgrade/keep.d/luci-app-adguardhome"
    mkdir -p "$(dirname "$keep_file")"
    : > "$keep_file" # Clear the file first
    for item in $upprotect; do
         # Basic variable substitution, assuming simple paths from config
         eval echo "\"$item\"" >> "$keep_file"
    done
    log "Updated sysupgrade keep file: $keep_file"


    # Start procd instance
    procd_open_instance
    get_tz # Get timezone
    [ -n "$SET_TZ" ] && procd_set_param env TZ="$SET_TZ"
    # Respawn parameters from original script
    procd_set_param respawn 3600 5 5
    # Set resource limits
    procd_set_param limits core="unlimited" nofile="65535 65535"
    procd_set_param stderr 1 # Redirect stderr to syslog
    # Use eval to handle quoted arguments correctly
    eval procd_set_param command "\"$binpath\"" $ADDITIONAL_ARGS
    # Add files to watch for changes (procd reload)
    procd_set_param file "$configpath" "/etc/hosts" "/etc/config/AdGuardHome"
    procd_close_instance

    # Handle redirection based on config status and redirect setting
    if [ -f "$configpath" ]; then
        log "Config file found. Applying redirect rules..."
        _do_redirect 1
    else
        log "Config file '$configpath' not found. Redirect disabled."
        _do_redirect 0
        if [ "$redirect" != "none" ]; then
            log "Starting watchconfig script as redirect is enabled but config is missing..."
            procd_open_instance "waitconfig"
            procd_set_param command "/usr/share/AdGuardHome/watchconfig.sh"
            # Consider respawn for watchconfig?
            procd_close_instance
        fi
    fi

    log "AdGuardHome service started (PID: $!). Enabled: $enabled, Redirect: $redirect"

    # Background check if process dies quickly
    (
        sleep 10
        if ! pgrep -f "^${binpath}" >/dev/null 2>&1; then
             log "AdGuardHome process not running after 10s. Disabling redirect."
             logger "AdGuardHome" "Error: Process died shortly after start. Check logs."
             # Use do_redirect 0 to safely disable and clean up
             do_redirect 0
        fi
     ) &
}

reload_service() {
    rm /var/run/AdGlucitest >/dev/null 2>&1 || true
    log "AdGuardHome reloading service..."
    # Procd handles reload by sending SIGHUP or restarting based on service definition
    # We might need to ensure config changes are picked up, procd file watch helps.
    # Forcing a restart might be safer if AGH doesn't handle SIGHUP well for all changes.
    # Let's use the 'start' function logic which reads config and restarts via procd.
    start
    log "AdGuardHome reload command issued."
}

# 优化 del_querylog
del_querylog() {
    local backupwdpath workdir btarget wtarget
    config_get backupwdpath "$CONFIGURATION" backupwdpath "/usr/bin/AdGuardHome"
    config_get workdir "$CONFIGURATION" workdir "/usr/bin/AdGuardHome"

    # Find the newest query log in backup and workdir (handle potential multiple files like querylog.json.1)
    # Use find instead of ls for safer parsing
    btarget=$(find "$backupwdpath/data" -maxdepth 1 -name 'querylog.json*' -printf '%T@ %p\n' 2>/dev/null | sort -nr | head -n 1 | cut -d' ' -f2-)
    wtarget=$(find "$workdir/data" -maxdepth 1 -name 'querylog.json*' -printf '%T@ %p\n' 2>/dev/null | sort -nr | head -n 1 | cut -d' ' -f2-)


    if [ -z "$btarget" ] && [ -z "$wtarget" ]; then
        log "No querylog files found to delete."
        return 1 # Indicate nothing was deleted
    fi

    # Decide which file to delete - prioritize deleting the backup first if it exists
    local file_to_delete=""
    if [ -n "$btarget" ]; then
        file_to_delete="$btarget"
         log "Deleting backup query log: $file_to_delete"
    elif [ -n "$wtarget" ]; then
        file_to_delete="$wtarget"
         log "Deleting workdir query log: $file_to_delete"
    fi


    if [ -n "$file_to_delete" ]; then
        rm -f "$file_to_delete" && { log "Deleted '$file_to_delete'."; return 0; } || { log "Error deleting '$file_to_delete'."; return 1; }
    fi

    return 1 # Should not happen if checks above are correct
}

stop_service() {
    config_load "${CONFIGURATION}"
    log "Stopping AdGuardHome service..."

    # Disable redirection first
    _do_redirect 0

    # Update crontab to disable tasks if service is disabled
    # Check enabled status before modifying crontab on stop
    local enabled
    config_get_bool enabled "$CONFIGURATION" enabled 0
    do_crontab # Pass enabled status implicitly via config_load

    # Perform backup if requested and not a temporary stop (e.g., during update)
    if [ "$1" != "nobackup" ]; then
        local backupfile
        config_get backupfile "$CONFIGURATION" backupfile "" # Read backup list
        if [ -n "$backupfile" ]; then
            log "Performing backup before stopping..."
            backup
        else
             log "No backup configured on stop."
        fi
    else
         log "Skipping backup on stop (reason: $1)."
    fi

    # Mark service as disabled (used by reload logic?)
    touch /var/run/AdGserverdis

    # Procd handles the actual stopping, this function mainly does cleanup/backup
    log "AdGuardHome service stop sequence initiated."
    # Let procd handle the actual process stop via init.d stop
}

boot() {
    # rc_procd expects the function name passed to it to handle boot tasks
    rc_procd boot_service "$@"
    # service_started is optional, handle if defined elsewhere
    if type service_started >/dev/null 2>&1; then
        service_started
    fi
}

test_crontab() {
    log "Testing crontab update..."
    config_load "${CONFIGURATION}"
    do_crontab
    log "Crontab test finished."
}


# 优化 crontab_editor
# Usage: crontab_editor "find_pattern" "default_command" enable_flag
# Sets global 'cronreload=1' if changes were made
crontab_editor() {
    local findstr="$1"
    local default="$2"
    local cronenable="$3" # 1 for enable, 0 for disable
    local current_cron reload_needed=0
    local modified_line=""

    # Read current crontab entry, handling potential comments
    # Use grep with extended regex for more flexibility if needed
    current_cron=$(grep "$findstr" "$CRON_FILE" || true)

    if [ -n "$current_cron" ]; then
        # Entry exists
        if [ "${current_cron#\#}" != "$current_cron" ]; then
            # Entry is commented out
            if [ "$cronenable" -eq 1 ]; then
                log "Enabling cron job: $findstr"
                modified_line="${current_cron#\#}" # Remove comment
                reload_needed=1
            else
                 # Already disabled, no change needed unless content needs update (not handled here)
                 :
            fi
        else
            # Entry is active
            if [ "$cronenable" -eq 0 ]; then
                log "Disabling cron job: $findstr"
                modified_line="#${current_cron}" # Add comment
                reload_needed=1
             else
                  # Already enabled, check if content matches default (basic check)
                  if [ "$current_cron" != "$default" ]; then
                       # Content differs, could be user modification or needs update
                       # Decide policy: update or leave user changes? Let's leave user changes for now.
                       # log "Cron job for '$findstr' differs from default, leaving user modifications."
                       : # No change
                  fi
            fi
        fi
    else
        # Entry does not exist
        if [ "$cronenable" -eq 1 ]; then
            log "Adding cron job: $findstr"
            modified_line="$default"
            reload_needed=1
        fi
    fi

    # Apply changes if needed
    if [ "$reload_needed" -eq 1 ]; then
        # Remove existing line(s) matching the pattern (commented or not)
        sed -i "\,$findstr,d" "$CRON_FILE"
        # Add the new or modified line
        echo "$modified_line" >> "$CRON_FILE"
        cronreload=1 # Signal that cron needs restart
        log "Crontab updated."
    fi
}

# 优化 do_crontab
do_crontab() {
    local enabled crontab cronreload=0
    config_get_bool enabled "$CONFIGURATION" enabled 0
    config_get crontab "$CONFIGURATION" crontab ""

    # Helper function to check if a feature is enabled in crontab string
    is_cron_feature_enabled() {
       [ "$enabled" -eq 1 ] && echo "$crontab" | grep -q "$1"
    }

    log "Updating crontab entries..."

    # Auto update core
    local update_cmd="/usr/share/AdGuardHome/update_core.sh >/dev/null 2>&1" # Redirect output
    local update_default="30 3 * * * $update_cmd"
    is_cron_feature_enabled "autoupdate" && crontab_editor "$update_cmd" "$update_default" 1 || crontab_editor "$update_cmd" "$update_default" 0

    # Auto tail querylog
    local workdir tail_cmd_query tail_default_query
    config_get workdir "$CONFIGURATION" workdir "/usr/bin/AdGuardHome"
    # Note: Using uci get inside cron is generally discouraged. Better to hardcode path if possible,
    # or have this init script update the cron job with the actual path.
    # Let's update the cron job with the actual path.
    tail_cmd_query="/usr/share/AdGuardHome/tailto.sh 2000 \"${workdir}/data/querylog.json\""
    tail_default_query="0 * * * * $tail_cmd_query"
    # Use a unique pattern for grep that includes the script name and querylog
    is_cron_feature_enabled "cutquerylog" && crontab_editor "/tailto.sh.*querylog.json" "$tail_default_query" 1 || crontab_editor "/tailto.sh.*querylog.json" "$tail_default_query" 0

    # Auto tail runtime log
    local logfile tail_cmd_runtime tail_default_runtime
    config_get logfile "$CONFIGURATION" logfile ""
    if [ -n "$logfile" ] && [ "$logfile" != "syslog" ]; then
        tail_cmd_runtime="/usr/share/AdGuardHome/tailto.sh 2000 \"${logfile}\""
        tail_default_runtime="30 3 * * * $tail_cmd_runtime"
         is_cron_feature_enabled "cutruntimelog" && crontab_editor "/tailto.sh.*${logfile}" "$tail_default_runtime" 1 || crontab_editor "/tailto.sh.*${logfile}" "$tail_default_runtime" 0
    else
        # Ensure disabled if logfile is empty or syslog
         log "Runtime log tailing disabled (logfile: '$logfile')."
         crontab_editor "/tailto.sh.*${logfile}" "" 0 # Pass empty default to ensure removal
    fi


    # Auto update ipv6 hosts
    local host_cmd="/usr/share/AdGuardHome/addhost.sh"
    local host_default="0 * * * * $host_cmd"
    is_cron_feature_enabled "autohost" && crontab_editor "$host_cmd" "$host_default" 1 || crontab_editor "$host_cmd" "$host_default" 0
    # Apply addhost.sh immediately based on current state (noreload needed if cron is managing it)
    # Check if the feature is *currently* enabled in the config string
    if is_cron_feature_enabled "autohost"; then
         log "Running addhost.sh (enabled)"
         /usr/share/AdGuardHome/addhost.sh "" "noreload" || log "addhost.sh failed"
    else
         log "Running addhost.sh del (disabled)"
         /usr/share/AdGuardHome/addhost.sh "del" "noreload" || log "addhost.sh del failed"
    fi


    # Auto update gfwlist
    local gfw_cmd="/usr/share/AdGuardHome/gfw2adg.sh"
    local gfw_default="30 3 * * * $gfw_cmd"
    is_cron_feature_enabled "autogfw" && crontab_editor "$gfw_cmd" "$gfw_default" 1 || crontab_editor "$gfw_cmd" "$gfw_default" 0

    # Auto update gfw ipset list (assuming gfwipset2adg.sh exists and is intended)
    local gfwipset_cmd="/usr/share/AdGuardHome/gfwipset2adg.sh"
    local gfwipset_default="31 3 * * * $gfwipset_cmd"
     is_cron_feature_enabled "autogfwipset" && crontab_editor "$gfwipset_cmd" "$gfwipset_default" 1 || crontab_editor "$gfwipset_cmd" "$gfwipset_default" 0

    # Restart cron if changes were made
    if [ "$cronreload" -eq 1 ]; then
        log "Restarting cron service due to crontab changes..."
        /etc/init.d/cron restart || log "Error restarting cron service."
    else
         log "No changes made to crontab."
    fi
}