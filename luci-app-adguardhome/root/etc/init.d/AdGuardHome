#!/bin/sh /etc/rc.common
# Copyright (C) 2018-2024 Lienol <https://github.com/Lienol>
# Copyright (C) 2024 rufengsuixing <https://github.com/rufengsuixing>

# 启用错误退出，但在管道或逻辑判断中需小心
set -e

USE_PROCD=1
START=95
STOP=01

CONFIGURATION="AdGuardHome"
CRON_FILE="/etc/crontabs/root"
GFWSET="gfwlist"
EXTRA_COMMANDS="do_redirect testbackup test_crontab force_reload isrunning"
EXTRA_HELP="        do_redirect 0 or 1
        testbackup backup or restore
        test_crontab
        force_reload
        isrunning"

log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - AdGuardHome Init: $1" >> /tmp/AdGuardHome_init.log
}

check_command() {
    command -v "$1" >/dev/null 2>&1 || { log "Error: command '$1' not found."; return 1; }
}

set_forward_dnsmasq() {
    local PORT="$1"
    local addr="127.0.0.1#${PORT}"
    local OLD_SERVER
    OLD_SERVER=$(uci -q get dhcp.@dnsmasq[0].server)
    
    if echo "$OLD_SERVER" | grep -q "^${addr}"; then
        return
    fi
    
    uci delete dhcp.@dnsmasq[0].server 2>/dev/null || true
    uci add_list dhcp.@dnsmasq[0].server="$addr"
    for server in $OLD_SERVER; do
        [ "$server" = "$addr" ] && continue
        uci add_list dhcp.@dnsmasq[0].server="$server"
    done
    uci delete dhcp.@dnsmasq[0].resolvfile 2>/dev/null || true
    uci set dhcp.@dnsmasq[0].noresolv=1
    uci commit dhcp
    log "Setting dnsmasq upstream to $addr"
    /etc/init.d/dnsmasq restart || log "Error restarting dnsmasq"
}

stop_forward_dnsmasq() {
    local OLD_PORT="$1"
    local addr="127.0.0.1#${OLD_PORT}"
    local OLD_SERVER
    OLD_SERVER=$(uci -q get dhcp.@dnsmasq[0].server)
    
    if ! echo "$OLD_SERVER" | grep -q "^${addr}"; then
        return
    fi

    uci del_list dhcp.@dnsmasq[0].server="$addr" 2>/dev/null || true
    
    local rcauto="/tmp/resolv.conf.auto"
    [ -e "/tmp/resolv.conf.d/resolv.conf.auto" ] && rcauto="/tmp/resolv.conf.d/resolv.conf.auto"

    local addrlist
    addrlist=$(uci -q get dhcp.@dnsmasq[0].server)
    if [ -z "$addrlist" ]; then
        uci set dhcp.@dnsmasq[0].resolvfile="$rcauto"
        uci delete dhcp.@dnsmasq[0].noresolv 2>/dev/null || true
    fi
    uci commit dhcp
    log "Removing dnsmasq upstream $addr"
    /etc/init.d/dnsmasq restart || log "Error restarting dnsmasq"
}

# 适配 Firewall4 (nftables)：通过 UCI 配置重定向
set_redirect_rule() {
    local port="$1"
    local section
    local name="AdGuard Home DNS"

    # 查找是否已存在规则
    section=$(uci show firewall | grep ".name='$name'" | awk -F. '{print $2}' | head -n1)
    
    if [ -z "$section" ]; then
        section=$(uci add firewall redirect)
    fi

    uci batch <<EOF
set firewall.$section.target="DNAT"
set firewall.$section.name="$name"
set firewall.$section.src="lan"
set firewall.$section.proto="tcp udp"
set firewall.$section.src_dport="53"
set firewall.$section.dest_port="${port}"
EOF
    uci commit firewall
    /etc/init.d/firewall reload || log "Error reloading firewall"
    log "Firewall redirect rule set for port ${port}."
}

clear_redirect_rule() {
    local redirects
    local name="AdGuard Home DNS"
    
    # 精确查找规则名称
    redirects=$(uci show firewall | grep ".name='$name'" | awk -F. '{print $2}')
    
    if [ -z "$redirects" ]; then
        log "No AdGuard Home DNS redirect rules found."
    else
        local changed=0
        for section in $redirects; do
            uci delete firewall."$section"
            log "Deleted redirect rule: firewall.$section"
            changed=1
        done
        if [ "$changed" -eq 1 ]; then
            uci commit firewall
            /etc/init.d/firewall reload || log "Error reloading firewall"
            log "Firewall rules cleared."
        fi
    fi
}

service_triggers() {
    procd_add_reload_trigger "$CONFIGURATION"
    [ "$(uci -q get AdGuardHome.AdGuardHome.redirect)" = "redirect" ] && procd_add_reload_trigger firewall
}

isrunning() {
    local binpath
    config_load "${CONFIGURATION}"
    config_get binpath "$CONFIGURATION" binpath "/usr/bin/AdGuardHome/AdGuardHome"
    [ ! -f "$binpath" ] && echo "no bin" && return 2
    if pgrep -f "^${binpath}" >/dev/null 2>&1; then
        echo "running"
        return 0
    else
        echo "not run"
        return 1
    fi
}

force_reload() {
    log "Force reloading AdGuardHome service..."
    /etc/init.d/AdGuardHome reload
}

get_tz() {
    SET_TZ=""
    local tz_config
    tz_config=$(uci -q get system.@system[0].timezone)
    if [ -n "$tz_config" ]; then
        SET_TZ="$tz_config"
        return
    fi
    if [ -e "/etc/TZ" ]; then
        SET_TZ=$(cat /etc/TZ)
    elif [ -e "/var/etc/TZ" ]; then
        SET_TZ=$(cat /var/etc/TZ)
    fi
}

# 简化的 config_editor，保持 awk 逻辑不变
config_editor() {
    local yaml_path="$1"
    local value="$2"
    local file="$3"
    local readonly="$4"

    [ -z "$file" ] || [ ! -f "$file" ] && { log "Error: Config file '$file' not found."; return 1; }

    awk -v yaml="$yaml_path" -v value="$value" -v file="$file" -v ro="$readonly" '
    BEGIN {
        split(yaml, parts, ".");
        target_depth = length(parts);
        current_depth = 1;
        in_correct_section = 1;
        indent_levels[0] = -1;
        found = 0;
    }
    {
        match($0, /^(\s*)/);
        indent = length(RLENGTH);
        line_content = substr($0, indent + 1);
        
        if (line_content == "" || substr(line_content, 1, 1) == "#") {
            print; next;
        }

        while (indent <= indent_levels[current_depth - 1] && current_depth > 1) {
            current_depth--;
            in_correct_section = (current_depth <= target_depth && parts[current_depth] == current_key[current_depth]);
        }
        indent_levels[current_depth] = indent;

        if (match(line_content, /^([^:]+):\s*(.*)/, arr)) {
            key = arr[1];
            current_val = arr[2];
            sub(/^\s+|\s+$/, "", key);
        } else {
            print; next;
        }

        current_key[current_depth] = key;
        is_target_path = 1;
        for (i = 1; i <= current_depth; i++) {
            if (parts[i] != current_key[i]) {
                is_target_path = 0; break;
            }
        }

        if (is_target_path && in_correct_section) {
            if (current_depth == target_depth) {
                found = 1;
                if (ro == "1") {
                    print current_val; exit;
                } else {
                    print substr($0, 1, indent) key ": " value;
                }
            } else {
                current_depth++;
                in_correct_section = 1;
                print;
            }
        } else {
             in_correct_section = 0;
             print;
        }
    }
    END {
        if (found == 0 && ro != "1") exit 1;
        if (found == 0 && ro == "1") exit 1;
    }' "$file" > "${file}.tmp"

    local ret=$?
    if [ "$readonly" != "1" ]; then
        if [ $ret -eq 0 ]; then
            mv "${file}.tmp" "$file"
            return 0
        else
            rm -f "${file}.tmp"
            return 1
        fi
    else
        rm -f "${file}.tmp"
        return $ret
    fi
}

rm_port53() {
    local configpath
    config_get configpath "$CONFIGURATION" configpath "/etc/AdGuardHome.yaml"
    local AdGuardHome_PORT
    AdGuardHome_PORT=$(config_editor "dns.port" "" "$configpath" "1")
    
    if [ -z "$AdGuardHome_PORT" ]; then return 1; fi

    local dnsmasq_port
    dnsmasq_port=$(uci -q get dhcp.@dnsmasq[0].port) || dnsmasq_port="53"

    if [ "$dnsmasq_port" = "$AdGuardHome_PORT" ]; then
        log "Ports clashed ($dnsmasq_port), moving dnsmasq back to 53."
    elif [ "$dnsmasq_port" = "53" ]; then
        return 0
    fi

    uci set dhcp.@dnsmasq[0].port="53"
    uci commit dhcp
    /etc/init.d/dnsmasq restart || log "Error restarting dnsmasq"
}

use_port53() {
    local configpath
    config_get configpath "$CONFIGURATION" configpath "/etc/AdGuardHome.yaml"
    local AdGuardHome_PORT
    AdGuardHome_PORT=$(config_editor "dns.port" "" "$configpath" "1")
    
    if [ -z "$AdGuardHome_PORT" ]; then return 1; fi

    local dnsmasq_port
    dnsmasq_port=$(uci -q get dhcp.@dnsmasq[0].port) || dnsmasq_port="53"

    if [ "$AdGuardHome_PORT" = "53" ]; then
        if [ "$dnsmasq_port" = "53" ]; then
             local new_dnsmasq_port="5353"
             uci set dhcp.@dnsmasq[0].port="$new_dnsmasq_port"
             uci commit dhcp
             /etc/init.d/dnsmasq restart || log "Error restarting dnsmasq"
        fi
    else
        local new_dnsmasq_port="$AdGuardHome_PORT"
        if [ "$dnsmasq_port" = "53" ]; then
            if config_editor "dns.port" "53" "$configpath"; then
                 uci set dhcp.@dnsmasq[0].port="$new_dnsmasq_port"
                 uci commit dhcp
                 /etc/init.d/dnsmasq restart || log "Error restarting dnsmasq"
            else
                 log "Error setting AdGuardHome port to 53."
                 return 1
            fi
        else
            if ! config_editor "dns.port" "53" "$configpath"; then
                  log "Error setting AdGuardHome port to 53."
                  return 1
             fi
        fi
    fi
}

do_redirect() {
    config_load "${CONFIGURATION}"
    local enabled="$1"
    local section="$CONFIGURATION"
    local configpath old_redirect redirect old_port AdGuardHome_PORT old_enabled

    if [ "$enabled" = "1" ]; then
        echo -n "1" > /var/run/AdGredir
    else
        echo -n "0" > /var/run/AdGredir
    fi

    config_get configpath "$section" configpath "/etc/AdGuardHome.yaml"
    if [ ! -f "$configpath" ] && [ "$enabled" = "1" ]; then
        enabled=0
        echo -n "0" > /var/run/AdGredir
    fi

    if [ "$enabled" = "1" ]; then
      AdGuardHome_PORT=$(config_editor "dns.port" "" "$configpath" "1")
      if [ -z "$AdGuardHome_PORT" ]; then
           enabled=0
           echo -n "0" > /var/run/AdGredir
      fi
    else
       AdGuardHome_PORT="0"
    fi

    config_get redirect "$section" redirect "none"
    config_get old_redirect "$section" old_redirect "none"
    config_get old_port "$section" old_port "0"
    config_get old_enabled "$section" old_enabled "0"
    
    uci -q get dhcp.@dnsmasq[0].port || uci set dhcp.@dnsmasq[0].port="53"

    local effective_old_agh_port="$old_port"
    if [ "$old_enabled" = "1" ] && [ "$old_redirect" = "exchange" ]; then
         effective_old_agh_port=$(uci -q get dhcp.@dnsmasq[0].port) || effective_old_agh_port="$old_port"
    fi

    if [ "$old_redirect" != "$redirect" ] || [ "$effective_old_agh_port" != "$AdGuardHome_PORT" ] || [ "$old_enabled" = "1" -a "$enabled" = "0" ]; then
        case "$old_redirect" in
            redirect)
                [ "$effective_old_agh_port" != "0" ] && clear_redirect_rule
                ;;
            dnsmasq-upstream)
                [ "$effective_old_agh_port" != "0" ] && stop_forward_dnsmasq "$effective_old_agh_port"
                ;;
            exchange)
                rm_port53
                ;;
        esac
    elif [ "$old_enabled" = "1" ] && [ "$enabled" = "1" ] && [ "$old_redirect" = "redirect" ] && [ "$effective_old_agh_port" != "0" ] && [ "$effective_old_agh_port" != "$AdGuardHome_PORT" ]; then
         clear_redirect_rule
    fi

    uci set "${CONFIGURATION}.${section}.old_redirect=$redirect"
    uci set "${CONFIGURATION}.${section}.old_port=$AdGuardHome_PORT"
    uci set "${CONFIGURATION}.${section}.old_enabled=$enabled"
    uci commit "$CONFIGURATION"

    [ "$enabled" = "0" ] && return 1
    [ "$AdGuardHome_PORT" = "0" ] && return 1

    case "$redirect" in
        redirect)
            set_redirect_rule "$AdGuardHome_PORT"
            ;;
        dnsmasq-upstream)
            set_forward_dnsmasq "$AdGuardHome_PORT"
            ;;
        exchange)
             use_port53
            ;;
    esac
}

boot_service() {
    rm /var/run/AdGserverdis >/dev/null 2>&1 || true
    config_load "${CONFIGURATION}"
    local waitonboot enabled binpath
    config_get waitonboot "$CONFIGURATION" waitonboot "0"
    config_get_bool enabled "$CONFIGURATION" enabled 0
    config_get binpath "$CONFIGURATION" binpath "/usr/bin/AdGuardHome/AdGuardHome"

    if [ ! -f "$binpath" ]; then
        log "AdGuardHome binary not found. Triggering update..."
        /usr/share/AdGuardHome/update_core.sh > /tmp/AdGuardHome_update.log 2>&1 &
        return 1
    fi

    start_service

    if [ "$enabled" = "1" ] && [ "$waitonboot" = "1" ]; then
        procd_open_instance "waitnet"
        procd_set_param command "/usr/share/AdGuardHome/waitnet.sh"
        procd_close_instance
    fi
}

start_service() {
    rm /var/run/AdGserverdis >/dev/null 2>&1 || true
    config_load "${CONFIGURATION}"

    local enabled hashpass configpath workdir binpath httpport logfile verbose redirect upprotect
    local ADDITIONAL_ARGS=""

    config_get_bool enabled "$CONFIGURATION" enabled 0
    config_get hashpass "$CONFIGURATION" hashpass ""
    config_get configpath "$CONFIGURATION" configpath "/etc/AdGuardHome.yaml"
    config_get workdir "$CONFIGURATION" workdir "/etc/AdGuardHome"
    config_get binpath "$CONFIGURATION" binpath "/usr/bin/AdGuardHome/AdGuardHome"
    config_get httpport "$CONFIGURATION" httpport 3000
    config_get logfile "$CONFIGURATION" logfile ""
    config_get_bool verbose "$CONFIGURATION" verbose 0
    config_get redirect "$CONFIGURATION" redirect "none"
    config_get upprotect "$CONFIGURATION" upprotect ""

    do_crontab

    if [ "$enabled" = "0" ]; then
        _do_redirect 0
        return 1
    fi

    if [ ! -f "$binpath" ]; then
        /usr/share/AdGuardHome/update_core.sh > /tmp/AdGuardHome_update.log 2>&1 &
        return 1
    fi

    if [ -n "$hashpass" ]; then
        if config_editor "users.0.password" "$hashpass" "$configpath"; then
            uci set "${CONFIGURATION}.${CONFIGURATION}.hashpass="
            uci commit "$CONFIGURATION"
        fi
    fi

    mkdir -p "$workdir/data" || { log "Error creating workdir '$workdir'"; return 1; }

    # ipset 检查：仅当 ipset 命令存在时尝试
    if [ -f "$configpath" ] && grep -qE '^\s*ipset:\s*\[.+\]' "$configpath"; then
         if command -v ipset >/dev/null 2>&1; then
             ipset list "$GFWSET" >/dev/null 2>&1 || ipset create "$GFWSET" hash:ip 2>/dev/null || true
         fi
    fi

    ADDITIONAL_ARGS="$ADDITIONAL_ARGS -c \"$configpath\""
    ADDITIONAL_ARGS="$ADDITIONAL_ARGS -w \"$workdir\""
    ADDITIONAL_ARGS="$ADDITIONAL_ARGS -p \"$httpport\""
    [ -n "$logfile" ] && ADDITIONAL_ARGS="$ADDITIONAL_ARGS -l \"$logfile\""
    [ "$verbose" -eq 1 ] && ADDITIONAL_ARGS="$ADDITIONAL_ARGS -v"

    # 处理 sysupgrade 保留列表
    local keep_file="/lib/upgrade/keep.d/luci-app-adguardhome"
    mkdir -p "$(dirname "$keep_file")"
    : > "$keep_file"
    for item in $upprotect; do
         eval echo "\"$item\"" >> "$keep_file"
    done

    procd_open_instance
    get_tz
    [ -n "$SET_TZ" ] && procd_set_param env TZ="$SET_TZ"
    procd_set_param respawn 3600 5 5
    procd_set_param limits core="unlimited" nofile="65535 65535"
    procd_set_param stdout 1 
    procd_set_param stderr 1 
    eval procd_set_param command "\"$binpath\"" $ADDITIONAL_ARGS
    # 增加对工作目录文件的监控
    procd_set_param file "$configpath" "/etc/hosts" "/etc/config/AdGuardHome"
    procd_close_instance

    if [ -f "$configpath" ]; then
        do_redirect 1
    else
        do_redirect 0
        if [ "$redirect" != "none" ]; then
            procd_open_instance "waitconfig"
            procd_set_param command "/usr/share/AdGuardHome/watchconfig.sh"
            procd_close_instance
        fi
    fi
}

reload_service() {
    start
}

stop_service() {
    config_load "${CONFIGURATION}"
    do_redirect 0
    touch /var/run/AdGserverdis
}

do_crontab() {
    local enabled crontab cronreload=0
    config_get_bool enabled "$CONFIGURATION" enabled 0
    config_get crontab "$CONFIGURATION" crontab ""

    is_cron_feature_enabled() {
       [ "$enabled" -eq 1 ] && echo "$crontab" | grep -q "$1"
    }

    local update_cmd="/usr/share/AdGuardHome/update_core.sh >/dev/null 2>&1"
    local update_default="30 3 * * * $update_cmd"
    
    if is_cron_feature_enabled "autoupdate"; then
        grep -qF "$update_cmd" "$CRON_FILE" || { echo "$update_default" >> "$CRON_FILE"; cronreload=1; }
    else
        if grep -qF "$update_cmd" "$CRON_FILE"; then
            sed -i "\,${update_cmd},d" "$CRON_FILE"
            cronreload=1
        fi
    fi
    
    if [ "$cronreload" -eq 1 ]; then
        /etc/init.d/cron restart
    fi
}